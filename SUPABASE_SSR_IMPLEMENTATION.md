# üöÄ Implementaci√≥n de SSR para Supabase en Next.js

## üìã Problema Identificado

La aplicaci√≥n actual no est√° implementando correctamente el **Server-Side Rendering (SSR)** para Supabase, lo que causa:

- ‚ùå **P√©rdida de conexi√≥n** cuando sales del navegador
- ‚ùå **Necesidad de recargar la p√°gina** constantemente
- ‚ùå **Sesiones inestables** que se pierden f√°cilmente
- ‚ùå **Falta de persistencia** entre navegaciones

## ‚úÖ Soluci√≥n Implementada

### 1. **Cliente Unificado de Supabase** (`lib/supabase/client.ts`)

```typescript
// Cliente del navegador optimizado para SSR
export function createBrowserSupabaseClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: false,
        flowType: 'pkce',
        storageKey: 'supabase-auth-token',
        sessionExpiryMargin: 300, // 5 minutos
        tokenRefreshMargin: 60, // 1 minuto
      },
      // ... m√°s configuraci√≥n
    }
  )
}

// Cliente del servidor para SSR
export function createServerSupabaseClient(cookieStore: ReturnType<typeof cookies>) {
  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: any) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // Error esperado en componentes del cliente
          }
        },
        remove(name: string, options: any) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch (error) {
            // Error esperado en componentes del cliente
          }
        },
      },
      auth: {
        autoRefreshToken: false, // No refrescar en el servidor
        persistSession: false, // No persistir en el servidor
      },
    }
  )
}
```

### 2. **Hook Mejorado con SSR** (`hooks/use-supabase-ssr.ts`)

```typescript
export function useSupabaseSSR(options: UseSupabaseSSROptions = {}): UseSupabaseSSRReturn {
  // ... configuraci√≥n
  
  // Funci√≥n para verificar la conexi√≥n con timeout
  const checkConnection = useCallback(async (): Promise<boolean> => {
    try {
      // Usar AbortController para timeout
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 10000) // 10 segundos timeout

      const { data, error } = await supabase
        .from('surveys')
        .select('id')
        .limit(1)
        .abortSignal(controller.signal)
      
      clearTimeout(timeoutId)
      
      if (error) {
        console.warn('‚ö†Ô∏è Error de conexi√≥n a Supabase:', error.message)
        return false
      }
      
      return true
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        console.warn('‚ö†Ô∏è Timeout en verificaci√≥n de conexi√≥n')
      } else {
        console.error('‚ùå Error cr√≠tico de conexi√≥n:', err)
      }
      return false
    }
  }, [])

  // Funci√≥n para reconectar con backoff exponencial
  const reconnect = useCallback(async (): Promise<void> => {
    if (retryCount.current >= maxRetries) {
      setError('Se alcanz√≥ el l√≠mite m√°ximo de reintentos')
      return
    }

    setLoading(true)
    retryCount.current++

    try {
      console.log(`üîÑ Reintentando conexi√≥n (${retryCount.current}/${maxRetries})...`)
      
      // Backoff exponencial
      const delay = Math.min(retryDelay * Math.pow(2, retryCount.current - 1), 30000)
      await new Promise(resolve => setTimeout(resolve, delay))
      
      const connected = await checkConnection()
      if (connected) {
        setIsConnected(true)
        setError(null)
        retryCount.current = 0
        console.log('‚úÖ Conexi√≥n restablecida')
      } else {
        throw new Error('No se pudo establecer la conexi√≥n')
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Error de reconexi√≥n'
      setError(errorMessage)
      console.error('‚ùå Error en reconexi√≥n:', errorMessage)
      
      // Programar siguiente reintento
      retryTimeout.current = setTimeout(() => {
        reconnect()
      }, retryDelay)
    } finally {
      setLoading(false)
    }
  }, [checkConnection, maxRetries, retryDelay])

  // ... m√°s funcionalidades
}
```

### 3. **Inicializaci√≥n de SSR en el Servidor** (`components/supabase-ssr-init.tsx`)

```typescript
export async function SupabaseSSRInit() {
  const cookieStore = cookies()
  const supabase = createServerSupabaseClient(cookieStore)

  try {
    // Verificar la sesi√≥n en el servidor
    const { data: { session }, error } = await supabase.auth.getSession()
    
    if (error) {
      console.error('‚ùå Error en SSR Supabase:', error.message)
    } else if (session) {
      console.log('‚úÖ Sesi√≥n v√°lida en SSR:', session.user.email)
    }

    return null
  } catch (err) {
    console.error('‚ùå Error cr√≠tico en SSR Supabase:', err)
    return null
  }
}
```

### 4. **Middleware Mejorado** (`middleware.ts`)

```typescript
export async function middleware(request: NextRequest) {
  // ... configuraci√≥n inicial
  
  try {
    // Crear cliente de Supabase en el middleware
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
      {
        cookies: {
          getAll: () => request.cookies.getAll(),
          setAll: (cookies) => {
            cookies.forEach(({ name, value, options }) => {
              response.cookies.set(name, value, options)
            })
          },
        },
        auth: {
          autoRefreshToken: false, // No refrescar en middleware
          persistSession: false, // No persistir en middleware
        },
      }
    )

    // Verificar sesi√≥n en el middleware
    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser()

    if (userError) {
      console.error('‚ùå Error obteniendo usuario en middleware:', userError.message)
    } else if (user) {
      console.log('‚úÖ Usuario autenticado en middleware:', user.email)
      
      // Refrescar token si es necesario
      const { data: { session } } = await supabase.auth.getSession()
      if (session) {
        // Verificar si el token est√° pr√≥ximo a expirar
        const expiresAt = session.expires_at
        const now = Math.floor(Date.now() / 1000)
        
        if (expiresAt && (expiresAt - now) < 300) { // 5 minutos antes de expirar
          console.log('üîÑ Token pr√≥ximo a expirar, refrescando...')
          try {
            const { data, error } = await supabase.auth.refreshSession()
            if (error) {
              console.warn('‚ö†Ô∏è Error refrescando token:', error.message)
            } else if (data.session) {
              console.log('‚úÖ Token refrescado exitosamente')
            }
          } catch (refreshError) {
            console.warn('‚ö†Ô∏è Error en refresh de token:', refreshError)
          }
        }
      }
    }

    // ... l√≥gica de rutas protegidas
  } catch (error) {
    console.error('‚ùå Error cr√≠tico en middleware:', error)
    return response
  }
}
```

### 5. **Layout Principal con SSR** (`app/layout.tsx`)

```typescript
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <MantineProvider>
          <ThemeProvider attribute="class" defaultTheme="light" enableSystem disableTransitionOnChange>
            {/* Inicializaci√≥n de Supabase en el servidor */}
            <SupabaseSSRInit />
            
            <SupabaseProvider 
              keepAlive={true}
              retryDelay={3000}
              maxRetries={5}
              useReadOnlyForQueries={true}
            >
              <ClientLayout>
                {children}
              </ClientLayout>
              <Toaster />
              <ConnectionStatus 
                showBadgeOnly={true}
                position="top-right"
                autoHide={true}
              />
            </SupabaseProvider>
          </ThemeProvider>
        </MantineProvider>
      </body>
    </html>
  )
}
```

## üîß Caracter√≠sticas Implementadas

### **Persistencia de Sesi√≥n**
- ‚úÖ **SSR completo** con verificaci√≥n de sesi√≥n en el servidor
- ‚úÖ **Cookies persistentes** para mantener la autenticaci√≥n
- ‚úÖ **Refresh autom√°tico de tokens** antes de que expiren
- ‚úÖ **Sincronizaci√≥n cliente-servidor** para estado consistente

### **Reconexi√≥n Inteligente**
- ‚úÖ **Backoff exponencial** para reintentos de conexi√≥n
- ‚úÖ **Verificaci√≥n de conexi√≥n** cada minuto
- ‚úÖ **Keep-alive** cada 30 segundos
- ‚úÖ **Detecci√≥n de cambios de red** (online/offline)

### **Manejo de Errores**
- ‚úÖ **Timeouts configurables** para operaciones
- ‚úÖ **L√≠mite de reintentos** configurable
- ‚úÖ **Logs detallados** para debugging
- ‚úÖ **Fallbacks graceful** en caso de errores

### **Seguridad**
- ‚úÖ **Headers de seguridad** en middleware
- ‚úÖ **Validaci√≥n de rutas** en el servidor
- ‚úÖ **Manejo seguro de cookies** para SSR
- ‚úÖ **Protecci√≥n contra ataques** comunes

## üöÄ Beneficios de la Implementaci√≥n

1. **üîí Sesiones Estables**: No m√°s p√©rdida de conexi√≥n al salir del navegador
2. **‚ö° Rendimiento Mejorado**: SSR reduce el tiempo de carga inicial
3. **üîÑ Reconexi√≥n Autom√°tica**: Se reconecta autom√°ticamente si se pierde la conexi√≥n
4. **üì± Mejor UX**: No m√°s necesidad de recargar la p√°gina constantemente
5. **üõ°Ô∏è Mayor Seguridad**: Validaci√≥n en el servidor y headers de seguridad
6. **üìä Monitoreo**: Logs detallados para debugging y monitoreo

## üìù Uso

### **En Componentes del Cliente**
```typescript
import { useSupabase } from '@/components/supabase-provider'

export function MyComponent() {
  const { supabase, isConnected, session, user, isSSRReady } = useSupabase()
  
  if (!isSSRReady) {
    return <div>Cargando...</div>
  }
  
  // Tu componente aqu√≠
}
```

### **En API Routes**
```typescript
import { createServerSupabaseClient } from '@/lib/supabase/client'
import { cookies } from 'next/headers'

export async function GET() {
  const cookieStore = cookies()
  const supabase = createServerSupabaseClient(cookieStore)
  
  const { data: { user } } = await supabase.auth.getUser()
  
  // Tu l√≥gica aqu√≠
}
```

## üîç Debugging

### **Logs del Servidor**
- ‚úÖ Sesiones v√°lidas en SSR
- ‚úÖ Usuarios autenticados en middleware
- ‚úÖ Tokens refrescados autom√°ticamente

### **Logs del Cliente**
- ‚úÖ Estado de conexi√≥n
- ‚úÖ Reintentos de reconexi√≥n
- ‚úÖ Cambios de estado de autenticaci√≥n

## üìö Recursos Adicionales

- [Documentaci√≥n oficial de Supabase SSR](https://supabase.com/docs/guides/auth/server-side/nextjs)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Middleware de Next.js](https://nextjs.org/docs/app/building-your-application/routing/middleware)

---

**üéØ Resultado**: Conexi√≥n de Supabase estable y persistente con SSR completo, eliminando la necesidad de recargar la p√°gina constantemente.
